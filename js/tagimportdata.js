table_data_coverage = [
    [1,"I think that there should be a system where you are writing code and it senses you’re stuck. Then it should step in and give you hints or offer a recommendation to you to help you move on. ", ["Functionality -> Recommendation modality -> Proactive: perceives when developer needs help"]],
    [1,"We have a very basic language without many coding keywords available. But the DO, IF, NEXT, PREV keywords are helpful.", ["Functionality -> Coverage of support -> Language keywords"]],
    [1,"I wish there were more recommendations for data processing.", ["Functionality -> Coverage of support"]],
    [1,"I would like to see coverage expand to more third party libraries. A lot of times I don't get code completion to work if the source file is not a part of my project. ", ["Functionality -> Coverage of support -> Support for third-party libraries"]],
    [1,"For very commonly used \"blocks\" of code, I wouldn't mind more advanced recommendations (ie. templates for common usages of for loops (counters, etc.). ", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Templates"]],
    [1,"The span of recommendations would help make the interface more user friendly.", ["Usability"]],
    [1,"I only use code completion for method calls, and I don't believe IntelliSense suggests variable names.", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [2,"I would like to try an editor able to recommend me variable names", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [2,"Entire line-statements rather than simple templates", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Entire statement(s)"]],
    [2,"There is little support for code statements implementing application logic. Most of the suggestions are related to method invocations, but for example I don't get suggestions for conditional statements in if, for, while, etc. This are also positions in which it's frequent to introduce bugs, thus could be useful to have suggestions.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Control structures"]],
    [2,"besides method call and imports the support provided is limited improvements are possible for all other types of statements. Cool can be suggesting which asserts as needed as the  code is written to test it.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Assert statements", "Functionality -> Coverage of support"]],
    [2,"My current stack does not cover templating and skeletons in general. Variable naming is partly supported but with minimum context analysis (which could be an improvement point). Method calling is supported (with decent results also on highly dynamic languages).", ["Functionality -> Coverage of support -> Support for identifiers", "Functionality -> Coverage of support -> Support for multi-token code completion ->  Templates"]],
    [2,"Some IDEs do not autocomplete the body and conditions of certain control structures", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Control structures"]],
    [2,"- I would like the possibility of create my own completions", ["Functionality -> Configurable -> Shortcuts definition"]],
    [2,"I use Eclipse for Java development and VSCode with Pylance for Python. Coverage is slightly better in Eclipse. With Pylance I would like to have a better typing check and more suggestions for chunks of code.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Entire Statement(s)", "Characteristics of recommended code -> Structural characteristics -> Type checked"]],
    [2,"when writing new functions I often create stubs of the other functions I need to invoke . the IDE could propose implementations for those stubs", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Implementation for stubs"]],
    [2,"support for identifiers is poor", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [2,"identifiers can be supported", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [3,"I would like to see it better able to predict certain often used code more quickly. ", ["Awareness -> Coding history"]],
    [3,"Pretty varying. A decent array of recommended variable names.", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [3,"I'd like to see parameter list generating for method invocations and filling in if and for statements.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Control structures", "Functionality -> Coverage of support -> Support for multi-token code completion -> Functions' Invocations/Parameters"]],
    [3,"its better to support suggestion of variables, class, method names beside the functions signature. Also generating of a basic template for a template calss is very usefull.", ["Functionality -> Coverage of support -> Support for identifiers", "Functionality -> Coverage of support -> Support for multi-token code completion -> Templates"]],
    [3,"code completion is useful in few scenarios: method invocations, imports. can improve on identifiers and application logic statements", ["Functionality -> Coverage of support -> Support for identifiers", "Functionality -> Coverage of support -> Support for multi-token code completion"]],
    [3,"repetitive code I often implement can be stored and proposed when I'm in a similar situation", ["Awareness -> Coding history"]],
    [3,"I rated the coverage medium, better support for naming variables and methods can help", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [3,"suggest identifiers, checks for good method names whole statement recommendation", ["Functionality -> Coverage of support -> Support for identifiers", "Functionality -> Coverage of support -> Support for multi-token code completion -> Entire statement(s)"]],
    [3,"Provide code related to what I'm actually writing. (e.g. libraries is a good starting point, if I'm using sklearn provide some recommendation about ML stuff)", ["Functionality -> Coverage of support -> Support for third-party libraries", "Awareness -> Coding context"]],
    [3,"Able to autocomplete when mixing languages such as auo-complete and suggestions for inline SQL code when writing database statements in C#", ["Functionality -> Coverage of support -> Multi-lingual code statements (e.g., C# and SQL)"]],
    [3,"I need the code completion tool to have the ability to recommend variable names and method calls. I also like to have hints for syntax errors and additional documentation. These things are important.", ["Functionality -> Coverage of support -> Support for identifiers"]],
    [4,"I would like it to provide code templates for common constructs and code patterns.  I would like something to remind me to DI the class I just created..a common oversight.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Templates"]],
    [4,"recommend method calls is more important than variable names. I would like to see improvement in the method call recommendation. ", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Functions' Invocations/Parameters"]],
    [4,"Recommendation will help improve the code consistency across different developer on the same project.", ["Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [4,"It would be nice to have more accurate recommendations based on the code I write. Usually I reuse certain methods and it'd be nice to have the plugin be aware of that.", ["Awareness -> Coding History"]],
    [4,"Recommend variable names from only the same document. Method names from same document and important documents.", ["Awareness -> Coding Context"]],
    [4,"copilot works well when recommending popular pieces of code (reading from file, opening a socket). recommendations more specific for the coding context of interest is needed", ["Awareness -> Coding Context"]],
    [4,"A wish to have a tool that understand my development task. It should provide smart suggestions and not only the predefined ones", ["Awareness -> Developer's Tasks", "Functionality -> Recommendation Modality -> Multiple options available"]],
    [4,"I wish to have a template in which I can define variable names and the tool automatically attaches the suggestion updated with my variable names", ["Functionality -> Coverage of Support -> Support for identifiers-> Asks developer when meaningful identifiers cannot be defined"]],
    [4,"Perhaps snippet code, as it happens with the tool SonarLint that provides many hints/suggestion to make good and robust code, could has high coverage.  ", ["Functionality -> Coverage of support -> Support for multi-token code completion", "Characteristics of recommended code -> Code quality -> Robustness"]],
    [4,"completion for several statements is still quite poor when the code features mixture of languages like python + sql, completion does not work", ["Functionality -> Coverage of support -> Support for multi-token code completion", "Functionality -> Coverage of support -> Multi-lingual code statements (e.g., c# and sql)"]],
    [4,"it works for most scenarios, but no support is provided for code imported from external projects", ["Functionality -> Coverage of support -> Support for third-party libraries"]]

];

table_data_accuracy = [
    [1,"When it comes to that, you’d like to see something that can be used 100 percent. There is no reason systems should be giving you bad help that can’t be used. ", ["Accuracy of recommendations -> Filtering based on confidence"]],
    [1,"I think accuracy is fine as it is at the moment if the suggest code is limited. I rarely use suggestions for extended pieces of code, I just use it to look up functions and variables. ", ["Characteristics of recommended code -> Code Quality -> High readability and understandability -> Concise code"]],
    [1,"It would be helpful if recommendations were more context sensitive. For example, if I type \"Math.\" in Java, the completion suggestions are usually alphabetical as I continue typing. I would like it if they were more refined (ranking things I have used frequently in this file higher, sensitive to closely related or frequently used together concepts [eg. Math.tan, Math.cos, etc.])", ["Awareness -> Coding history", "Functionality -> Recommendation modality -> Smart ranking"]],
    [1,"The code completion needs to be very accurate in order to complete correct calls.", ["Accuracy of recommendations"]],
    [2,"Use the history of my past programming activities to sort the suggestions. Also, the suggestions can be sorted also using the project I'm working in. In different projects I tend to do several times the same implementation tasks.", ["Awareness -> Coding history", "Awareness -> Coding context", "Functionality -> Recommendation modality -> Smart ranking"]],
    [2,"can be improved adapting the recommendations to my coding history, to what I'm doing in that moment", ["Awareness -> Coding history", "Awareness -> Developer's tasks"]],
    [2,"An adaptive autocompletion that learns from the choices made by the programmer would be interesting", ["Functionality -> Self-improving based on feedback"]],
    [2,"More adaptability to the own code conventions, It´s true that programming languages are their own code conventions but not all the programmers use the same.", ["Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [2,"the accuracy is ok, it can be improved learning from my programming, how I code, which libraries I prefer", ["Characteristics of recommended code -> Adaptive -> Developer's coding style", "Awareness -> Developers' knowledge", "Awareness -> Coding history"]],
    [2,"good for method invocations, poor/null for identifiers, can impove by learning from system;s vocabulary", ["Functionality -> Coverage of support -> Support for identifiers", "Characteristics of recommended code -> Adaptive  -> Coding context -> System's vocabulary"]],
    [2,"collecting feedback about what is used and what not when a recommendation pops up", ["Functionality -> Self-improving based on feedback"]],
    [2,"Accuracy is an important factor, and I prefer a tool that recommend less things with higher accuracy than viceversa. Currently, the IDE that I use never recommends something wrong. However, what I'd like to see more would be prioritizing the recommendations. For example, if a class has 3 method (getA, getB, getC) and I start typing \"var a = get...\" the IDE should prioritize the method getA, since the name of the variable gives an indication of what I'd like. This already works most of the time and it's really useful, however for more complicated cases it doesn't. ", ["Accuracy of recommendations", "Awareness -> Coding context", "Functionality -> Recommendation modality -> Smart ranking"]],
    [3,"I'd prefer highest possible accuracy. However, if that isn't obtainable, simply just having a template (fake variable names, but in general structure of if statement or for loop) that is placed that is highly accurate would be very helpful. ", ["Accuracy of recommendations -> Filtering based on confidence -> Templating in low-confidence scenarios"]],
    [3,"The code recommendation should be able to understand what context the developer is actually working in. For example. I am working on a webapp for a supermarket. I'm developing the functionality to manage payments, so recommendations have to be weighed in relation to that functionality.", ["Awareness -> Coding context", "Awareness -> Developer's tasks"]],
    [3,"in most of the time the code completion do not coverage most the featurs, but the suggestions are very accurate in 90% of the time.", ["Functionality -> Coverage of support"]],
    [3,"focus on current project, past usage of recommendations, my usage of libraries", ["Awareness -> Coding context", "Functionality -> Self-improving based on feedback", "Awareness -> Developers' knowledge"]],
    [3,"Maybe It can be useful to get clever suggestions for importing classes with the same name looking at their code and the caller context", ["Awareness -> Coding context"]],
    [3,"see before - using my past preferences", ["Functionality -> Self-improving based on feedback"]],
    [3,"for the supported statements accuracy is very good. I don't know if it learns from my choices, if not it shuold", ["Functionality -> Self-improving based on feedback"]],
    [3,"when recommending APIs consider those I use the most as high priority", ["Awareness -> Developers' knowledge"]],
    [3,"Provide recommendations related to the context. For instance, often the recommended code does not concern the library that I'm using in a project. Give priority to some kind of function based on libraries could be a great improvement.", ["Functionality -> Coverage of support -> Support for third-party libraries"]],
    [3,"Assessing based on a profile across applications I work on based on similarity.  If I work on many applications, it would be cool if the auto-complete could take the whole of what I work on and my style into consideration.", ["Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [4,"Accuracy is key, I'm pleased with the current accuracy which seems above 90%.", ["Accuracy of recommendations"]],
    [4,"VSCode Intellisense is very good at recommending obscure macros in a header somewhere, while almost always more local tokens are more interesting. Also if I just used `value_x` it is unlikely I want it again when I type `value_` again in the same line (`value_y` would be a better choice).", ["Awareness -> Coding Context", "Characteristics of recommended code -> Code Quality -> Correctness -> Correct Syntax"]],
    [4,"Scenarios where Intellisense guesses some library function and imports it at the top of a JS file are nearly always wrong. Would be nice to have more contextual recommendations.", ["Awareness -> Coding Context", "Functionality -> Coverage of support -> Support for third-party libraries"]],
    [4,"The actual suggestions is sometime correct. Still I prefer to receive zero suggestions rather than a list of incorrect ones", ["Accuracy of Recommendations -> Filtering based on confidence"]],
    [4,"Accuracy must be the priority, the tool cannot suggest wrong or unworking codes", ["Accuracy of recommendations"]],
    [4,"tools like copilot work very well, but sometimes the code you get is almost what you need, but not exactly, may be better to abstract parts on which tool is not sure with parts left to the dev", ["Accuracy of recommendations -> Filtering based on confidence -> Templating in low-confidence scenarios"]],
    [4,"often the recommendation is correct but it doesn't match the project's programming style so I accept the recommendation but then I have to adjust it to match the programming style. It would be great if the tool would provide suggestion matching the programing style", ["Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [4,"now that more complex recommendations are possible thanks to tools like copilot aspects related to code quality should be taken into account more, for example among two possible recommendations, pick the one with better performance", ["Characteristics of recommended code -> Code Quality -> Performance"]],
    [4,"When importing classes with the same name, always rank higher internal (declared in project) compared to external (found in libraries) classes", ["Functionality -> Recommendation modality -> Smart ranking"]],
    [4,"suggestions should be smarter and consider more stuff into consideration. like my previous code.", ["Awareness -> Coding history"]],
    [4,"Standard IDE very high. copilot is risky, not always easy to understand if what you get is what you look fore, sometims there are very minor differences that may result in bugs", ["Characteristics of recommended code -> Code quality -> Correctness -> Bug/Vulnerability free", "Characteristics of recommended code -> Code quality -> High readability and understandability"]]


];

table_data_usability = [
    [1,"To me the one I use is very friendly. I think that it should be that way as it’s there to help you and not hinder you. ", ["Usability -> Non-invasive"]],
    [1,"Not for beginners that is for sure", ["Usability -> Intuitive"]],
    [1,"I don't have many issues with the current usability of my code completion tools. I like them to be non-invasive, so that they aren't a distraction when I'm not using them. Generally they are good at this.", ["Usability -> Non-invasive"]],
    [1,"The UI is simple, providing several options and a single click completion", ["Functionality -> Configurable", "Usability -> No overhead while coding"]],
    [1,"The user interface has to be designed in a way that any normal user can use and not just a programmer.", ["Usability -> Intuitive"]],
    [1,"It's very user friendly and works out of the box, although I might suggest that it doesn't start making suggestions quite so fast. ", ["Usability -> High responsiveness"]],
    [2,"Integrated in the IDE, non-intrusive with the developer's flow. Recommendations should be easy to see but not overwhelming", ["Usability -> Non-invasive", "Usability -> Integrated with IDE"]],
    [2,"It's already very good. If the suggestions are smarter and based on past history, I would like to have the explanation for a suggestion (why I'm showing that based on what you did).", ["Functionality -> Provides additional information ->  Provides rationale justifying the recommendation", "Awareness -> Coding history"]],
    [2,"better support for refactoring", ["Functionality -> Coverage of support -> Autocomplete refactorings"]],
    [2,"overall ok, can improve with customisation ", ["Functionality -> Configurable"]],
    [2,"examples of API/method usage can be shown", ["Functionality -> Provides additional information -> Documentation -> Code example"]],
    [2,"The IDE should recommend something without obstructing the view of the developer, and without forcing the developer to focus on the recommendation (for example, if I start typing something, and the IDE would like to suggest me something, I need to have a way to ignore and continue). ", ["Usability -> Non-invasive"]],
    [3,"I'd like to see similar systems of google's recent smart compose where part of the recommendation is greyed out while you are typing showing what you could add. Navigating a bunch of options in a list, especially for very simple things becomes very annoying.", ["Usability -> Intuitive"]],
    [3,"Integrated in the IDE like suggestions for code completion", ["Usability -> Integrated with IDE"]],
    [3,"It's fine as long as it won't interfere with my normal coding.", ["Usability -> Non-invasive"]],
    [3,"In functions, show the different signature of the function, readablity of the suggestion and ease of use in case of control and choose between suggestion is very important and i can rate the tools and plugin with score 70. Also the ability to edit most different part of a generated code such as refactor feature to rename a generated variable name and the smartness of the feature is another case that increase the usability of the tools. I rate my exprienced tools  and IDEs plugin up to 60 in the case.", ["Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Usability -> Intuitive"]],
    [3,"I don't have huge improvements to propose, the user interface should be as clever as possible, also with a description of the recommended method and/or function. ", ["Functionality -> Provides additional information -> Documentation -> Commented code", "Usability"]],
    [3,"It would be nice to have the option to mark completions as unhelpful (but not by default) so that I do not see less useful ones.", ["Functionality -> Self-improving based on feedback"]],
    [4,"Autocomplete with auto-import can be exceedingly annoying with the default settings. I find myself hitting `esc` a bunch to dismiss the suggestion, or sometimes arrow-scrolling through a long list to get what I needed.", ["Usability -> No overhead while coding"]],
    [4,"Both have an easy user interface with keyboard shortcuts to bring up the recommendation.", ["Functionality -> Configurable"]],
    [4,"Not very friendly in vscode", ["Usability"]],
    [4,"highlight the parts of code that should be changed to fit the code", ["Functionality -> Provides additional information -> Highlights required edits"]],
    [4,"as long as no context-switch is required, I'm happy. recommendations should appear right were I code", ["Usability -> Integrated with IDE"]],
    [4,"sometimes the IDE's suggestions (like autocompletion for the variable names) are not shown in favor of the Copilot's suggestions that are less likely the correct ones. In those cases it would be better if the IDE's suggestion would be prompted instead of the Copilot's ones", ["Functionality -> Configurable"]],
    [4,"A “peek” window that show the context or at least the body of the method call / class from the list of suggestions we want to use / import", ["Functionality -> Provides additional information"]]


];

table_data_characteristics = [
    [1,"I think that it needs to be congruent e we it’s what I would write and this be a true helper to me. Once it learns my coding style it should go with that as it’s default helping technique. This would make it adapt to whatever I’m doing as it’s following what it knows about me and what I’m doing right now. ", ["Accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Developer's coding style", "Awareness -> Developer's tasks"]],
    [1,"The coding suggestions should be accurate based on a partial search. It should keep track of my open braces for loops whether nested or standalone. ", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness -> Correct syntax"]],
    [1,"Clean interface making it easy to use is pretty important. How accurate the recommendation is is of course very important as well and the amount of support it offers is probably the least important of the three ", ["Usability -> Intuitive", "Accuracy of recommendations", "Functionality -> Coverage of support"]],
    [1,"For me, correctness is the most important because I do mostly maintenance on production applications and don't do new development often. Functionality has to remain the same to avoid potential issues.</br>Ease of use is the next, I shouldn't really have to think too much about it or read a wall of text. I have too many other priorities and fires to put out during a day.</br>Provide a simple explanation, it should give a quick reason that I can understand why it's suggesting I do it. Otherwise I'd have to waste time doing research on why it's giving me that recommendation.", ["Characteristics of recommended code -> Code Quality -> Correctness", "usability -> no overhead while coding", "Functionality -> Provides additional information ->  Provides rationale justifying the recommendation"]],
    [1,"Accuracy- Weve had issues in the past over not being as accurate as we'd like.</br>Communication-We have to beall in and 100% agree", ["Accuracy of recommendations"]],
    [1,"Correctness (The code needs to be as close to what I am looking for as possible.)</br>Feasibility (The code needs to be something tat the users would expect to see.)</br>Industry Standard (The code needs to follow closely to what the client would want to see.)", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Meets best coding practices -> Meets company/client standards "]],
    [1,"- Speed, these recommendation systems are often slow and lag the entire UI, especially on large projects or if the system has extended features. </br>- Accuracy, if the code isn't accurate I'm going to turn it off. I rarely have this problem. </br>- Configurable, I want to be able to pick and choose what is recommended, preferably to disable things and speed up the recommendation system. ", ["Usability -> High responsiveness", "Accuracy of recommendations", "Functionality -> Configurable"]],
    [1,"Definitely correctness, without that nothing else really matters", ["Characteristics of recommended code -> Code Quality -> Correctness"]],
    [1,"Correctness would be the most important, as inaccurate recommendations would create more work than manually writing the code. Context-sensitivity is also important. I would like practical and stylistic compatibility with the existing code. Also important would be ease-of-use. It needs to be very clear what the recommended code is, what (if anything) still needs to be manually edited (variable names, constants, etc.), and how to accept or cycle through recommendation options. While typing manually, the recommendations shouldn't be too intrusive unless interacted with.", ["Accuracy of recommendations", "Awareness -> Coding context", "Characteristics of recommended code -> Adaptive -> Developer's coding style", "Functionality -> Provides additional information -> Highlights required edits", "Usability -> Non-invasive"]],
    [1,"I have been using this for so many years now that I don't really have any issues and find the correctness to be wonderful.  I can typically adapt it to the context that I am writing with only minimal changes and it is documented correctly.", ["Accuracy of recommendations", "Functionality -> Provides additional information -> Documentation -> Commented code"]],
    [1,"In my opinion, correctness trumps all other concerns. It doesn't have to be exactly how I would write it, but it needs to be functional and do what I intend it to do. ", ["Accuracy of recommendations"]],
    [1,"I think the user friendliness impacts the usefulness the most because it allows for more accessibility and variety in sourcing.", ["Usability -> Intuitive"]],
    [1,"I don't get the choice of what to use as an IDE at work, so this really doesn't apply, I'd like to have it more like an AI that will learn my style and make suggestions. This may or may not exist elsewhere, but I don't really have the option to use it.", ["Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [1,"The biggest impact is that it's actually giving me the right recommendation for what I'm working on at the time. This has been a problem for me just recently. ", ["Accuracy of recommendations", "Awareness -> Coding Context"]],
    [1,"Syntax, I want to be able to choose what I need and move on without worrying about breaking my momentum.  I like being able to quickly see my options, choose one, and continue with my work.</br>Documentation, I like to be able to have comments added quickly in case my co-workers need to look at the code in my absence. </br>Consistency.  I like variables and parameters to be consistent throughout the project", ["Characteristics of recommended code -> Code Quality -> Correctness -> correct syntax", "Usability -> Intuitive", "Functionality -> Provides additional information -> Documentation -> Commented code", "Characteristics of recommended code -> Adaptive  -> Coding context -> Identifier names", "usability -> no overhead while coding"]],
    [1,"1. Coverage/ usability</br>I think coverage is the bulwark for workable code because a code that's able to be used in a variety of different environments is going to be a very sturdy code with very little errors/fragility.</br>2. Open source.</br>I still believe that codes need to be open source so they can be shopped around and tested by a wider audience than just, well, testers like myself.</br>3. Programming language.</br>Python remains basically the industry standard and best programming language around, so I wouldn't recommend programmers get too ambitious or tricky with the code they decide to use. Programmers should conform to the standards for the sake of usability, not work with some novel code that has less widespread use.", ["Functionality -> Coverage of support", "Functionality -> Recommendation modality -> Open source"]],
    [1,"Documented because I like to know what each line of code does. Correctness because I like for the code to be generated close to what I would normally write. Adapted to context because it will save me time programming.", ["Functionality -> Provides additional information -> Documentation -> commented code", "accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Coding context"]],
    [1,"I think that correctness is the most important characteristic along with speed. Speed is underrated because I don't want to wait for suggestions to load.", ["Accuracy of recommendations", "Usability -> High responsiveness"]],
    [1,"Accuracy - correct and flawless</br>user friendly - easy to use </br>flexibility - keep up with future changes ", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability free", "Usability -> Intuitive"]],
    [1,"The correctness is the most important thing that matters to me when I am coding, there are similar strings that can accomplish similar tasks and I want to make sure that I am using the correct one for the situation. </br>The next most important thing to me when it comes to using an IDE Is that it understands the context I am working in, like when I work with Splunk and it is able to pull from the API to allow me to get more accurate commands to work with the software.</br>The third most important thing for me with an IDE is when it has syntax highlighting. This allows me to make sure that I am being accurate and matching syntax.", ["Accuracy of recommendations", "Awareness -> Coding context"]],
    [2,"I use code completion mostly for 2 purposes:</br>1) efficiency: to save keystrokes and complete name of variables/methods. I consider this efficiency not only because of the avoided keystrokes, but also because I am often not sure about the name of the variable/method and with completion I am sure it is correct without scrolling/navigating to look for it.</br>For this the important characteristics are that it suggest what I want as soon (with fewer character) as possible, which means has to be correct, adapted to the context and learned from history.</br>2) exploring apis/libraries: when I have an object from a given library/api and I know what I need to do with it, but I dunno which methods is provided to do that, I trigger the completion and look for what I need. In case i need more information, i ctrl+click and look at the implementation/signature of the method.</br>For this, it would be best if the completion are proposed not alphabetically in the dropdown but in likelihood that could be inferred from the context</br></br>I do not use completion that suggests entire snippet. The reason is that if I get an entire snippet I'll need to understand it to make sure is what I need and based on my experience this is not faster than writing the code myself. Instead of this, what I'd prefer is a sort of corrector that if the snippet that I just wrote is very similar to other existing, would highlight the differences that might be errors.", ["Accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Early prediction", "Awareness -> Coding history", "Characteristics of recommended code -> Code Quality -> High readability and understandability -> Concise code"]],
    [2,"The most important aspect is the clearness of the recommendation to allow the user to easily evaluate whether to take it or not, secondly the correctness in a way that the IDE must never recommend a solution that leads to a misfunctioning in place of the one, proposed by the user, that is actually working", ["Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Characteristics of recommended code -> Code Quality -> Correctness"]],
    [2,"- it should be correct</br>- it should be \"the canonical way\" (i.e: don't suggest me a \"while true\" if a \"loop do\" construct exists</br>- it should be readable, at most asking me for extra information. i.e:</br>elements.each_with_index do | a,b |</br>is not good</br>elements.each_with_index do | elem, index| </br>is good for the scoped variables. Instead of putting arbitrarily a and b, it would be better to ask me how would I'd like to call them", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Meets best coding practices ", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Functionality -> Coverage of support -> Support for identifiers -> Asks developer when meaningful identifiers cannot be defined"]],
    [2,"Correctness: the recommended code shall reflect my (or my team's) way of writing code</br>Adapted to the context: see above</br>Documented: automatic comments could be a real treat", ["Characteristics of recommended code -> Adaptive -> Developer's coding style", "Functionality -> Provides additional information -> Documentation -> Commented code", "Characteristics of recommended code -> Adaptive -> Coding context"]],
    [2,"- long enough: the prediction should represent a number of tokens/chracters that is worth to suggest, rather than few tokens that the developer can simply type.</br>- non-intrusive: it should not break the flow of development/typing</br>- based on best practices: I would expect the suggestions to be code that follow best practices, not simply the common solution", ["Functionality -> Coverage of support -> Support for multi-token code completion", "Usability -> Non-invasive", "Characteristics of recommended code -> Code Quality -> Meets best coding practices "]],
    [2,"1) Context adaptation: it's fundamental to receive suggestions related to the context I'm coding and not getting the general suggestion (which is most of the times just annoying).</br>2) Related second (or more) choices: this is related to the first point. In case the tool is not able to narrow down to the exact context, it would be desirable to have multiple choices.</br>3) Documented: as written in the example.", ["Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Recommendation modality -> Multiple options available", "Functionality -> Provides additional information -> Documentation -> Commented code"]],
    [2,"Support non-trivial coding: code competion provides good support in finding the right API in a class, and a few other things, but rarely suggest something challenging such as conditional statements.</br>Transparent  (it must speed up the implementation not slow down with useless suggestions). It must be possible to configure the suggestions, to get less but more likely to be correct.</br>Clear: Assuming the code is not trivial, a documentation/explanation for the suggestion is neeeded.", ["Functionality -> Coverage of support -> Support for multi-token code completion", "Accuracy of recommendations -> Filtering based on confidence", "Usability -> No overhead while coding", "Functionality -> Provides additional information -> Documentation -> Commented code"]],
    [2,"overall it must be a timesaver and help with repetitive tasks</br>others: correctness, adequate suggestions (e.g., not distracting from what I need to get done), fast and intuitive to use (e.g., should be a time saver), not getting in the way of the work, quick info/documentation should be available so that I can save time without having to go to the full documentation", ["Awareness -> Coding history", "Accuracy of recommendations", "Usability -> Non-invasive", "Usability -> High responsiveness", "Usability -> Intuitive"]],
    [2,"for code completion correctness is the most important. if we're looking to more complex code recommenders that can generate snippets of code, there documentation become important and fitting in the code writing without generating chaos. </br>the coverage is also important.", ["Accuracy of recommendations", "Functionality -> Provides additional information -> Documentation -> Commented code", "Characteristics of recommended code -> Structural characteristics -> Easy to integrate in code under development", "Functionality -> Coverage of support"]],
    [2,"Correctness: it is important, to understand more easily the suggestion, that the produced code is as much similar to mine as possible </br>Adapted to the context: it is also important that produced code uses the same variables that I use in all the code</br>Ask for help: A good recommender system should ask a brief description of what I want to do to try to achieve the wanted code i.e. use more initial information to understand which code should be produced", ["Characteristics of recommended code -> Adaptive -> Developer's coding style", "Characteristics of recommended code -> Adaptive  -> Coding context -> Identifier names", "Functionality -> Recommendation modality -> Ask additional information when what the developer is doing is not clear", "Characteristics of recommended code -> Adaptive -> Coding context"]],
    [2,"Correctness: the RS should have a minimum amount of false positive hits. Sometimes I feel like some colleagues suffer from IDE driven programming.</br>It should encourage good standards. If in Java a create a variable in kebab case, it should not suggest me to re-use it later on.</br>It should not add automatic comments: writing comments it's my job as the author (I should give the human insights not the machine's ones).</br>When naming variables, it should encourage clear naming (preferring things like NAME + QUALITY e.g. Car carOld, carNew as opposed to Car oldCar, newCar) checking for nouns and adjective. It should not suggest long names.", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Meets best coding practices ", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability -> Meaningful identifiers"]],
    [2,"Correctness (the recommended code must be semantically equivalent to the one I would manually write)</br>Smart (in the case of equivalent solutions, the best solution weighed in terms of complexity and comprehensibility should be proposed)</br>Relevant (the list of proposed solutions should be ordered according to relevance in the context)", ["Accuracy of recommendations", "Functionality -> Recommendation modality -> Smart ranking", "Awareness -> Coding context"]],
    [2,"Correctness, Adapted to the context, Documented, Translate to the code language, ", ["Accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Provides additional information -> Documentation -> Commented code"]],
    [2,"- Context sensitivity (some IDE recommend a completion that it is not applicable in a specific context)</br>- Typed code sensitivity (the recommended code must suggest a completion relying on what is the previously typed code)</br>- Speed (the main purpose is obviously to speed up che coding, if the system is slow than the coder it´s not useful)", ["Awareness -> Coding context", "Functionality -> Early prediction"]],
    [2,"Correctness is most important. If the recommender fails regularly, I won't be tempted to use it as much. </br>Suggestions that avoid having to switch back-and-forth (like importing library (components) of which I don't know the exact name, auto-completion of variable names and suggestion for parameters) are more important than suggestions that avoid typing work (like auto-generating getters and setters). </br>Also unambiguity is important. Pylance sometimes suggests multiple imports with the same name, it's not always immediately clear which is which. ", ["Accuracy of recommendations", "Functionality -> Coverage of support -> Support for multi-token code completion -> Functions' Invocations/Parameters", "Characteristics of recommended code -> Structural characteristics -> Unambiguous", "Functionality -> Coverage of support -> Support for identifiers"]],
    [2,"Correctness</br>Contextualized based on my programming history/preferences</br>In case a recommendation is not used, it must learn to avoid this recommendation in similar contexts in the future", ["Accuracy of recommendations", "Awareness -> Coding history", "Characteristics of recommended code -> Adaptive -> Developer's coding style", "Functionality -> Self-improving based on feedback"]],
    [2,"- Fast: recommendations needs to be fast;</br>- Correct: recommendations needs to be correct, otherwise developers won't rely on them.", ["Functionality -> Early prediction", "Accuracy of recommendations"]],
    [2,"easy to understand the code and why is recommended</br>not breaking syntax</br>meets coding standaard of company in terms of code quality, we use a tool check code issues", ["Characteristics of recommended code -> Code Quality -> Correctness -> Correct syntax", "Functionality -> Provides additional information ->  Provides rationale justifying the recommendation", "Characteristics of recommended code -> Code Quality -> Meets best coding practices  -> Meets company/client standards", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability"]],
    [2,"easy of use</br> precise</br> responsive</br> without these three it slows down the code writing", ["Usability -> Intuitive", "Accuracy of recommendations", "Usability -> High responsiveness"]],
    [2,"Accuracy is the most important one, more than coverage. </br>Context aware as well, it's important that if more than 1 recommendation is available, they are prioritized based on the context.", ["Accuracy of recommendations", "Awareness -> Coding context", "Functionality -> Recommendation modality -> Smart ranking"]],
    [3,"How soon it can predict what I'm trying to type. A lot of times triggers when I'm already almost finished typing so I just don't bother with it. </br></br>Whether or not it actually gives me insights rather than just autocompletion type of thing.</br>Whether or not it's correct", ["Functionality -> Early prediction", "Characteristics of recommended code -> Code Quality -> Correctness"]],
    [3,"Correctness than documented and then adapted to the context. ", ["Characteristics of recommended code -> Code Quality -> Correctness", "Functionality -> Provides additional information -> Documentation", "Awareness -> Coding context"]],
    [3,"- Correctness (the code must cooperate w the one I wrote manually. It has to flow conjunctionally)</br>- Adaption (the code adapts to the code I write)</br>- Documentation (the recommended code must align automatically)", ["Accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Coding context", "Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [3,"Correctness: I'd prefer it to recommend code that is even higher quality to the one I would write. This is especially important in terms of security because as a non-security expert, writing code that deals with sensitive data or protocols is intense.</br>If the recommender is not of higher accuracy, I'd prefer it perform templating because if it shows useless options to me (ones I have to heavily modify). However, if I expect that it will just generate the general structure for me, I'm fine to keep using it.</br>Easy to understand code is also important, so the kind of code it generates should follow a similar style to the one I already have. And documented code is also always nice (templates for this is also fine essentially reminding me that I will need to go back and fill in what the model couldn't do).", ["Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability Free", "Accuracy of recommendations -> Filtering based on confidence -> Templating in low-confidence scenarios", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Functionality -> Provides additional information -> Documentation", "Characteristics of recommended code -> Adaptive -> Developer's coding style"]],
    [3,"Adapted to the context</br>Customizable (e.g. generation of a for loop structure in intellij with \"fori\")</br>adhering to best practices</br>adhering to custom coding style rules or convetions</br>simple and radable", ["Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Configurable", "Characteristics of recommended code -> Code Quality -> Meets best coding practices ", "Characteristics of recommended code -> Adaptive -> Developer's coding style", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability"]],
    [3,"- It shouldn't change the code without my confirmation, even though the code is not logically right. A warning would be nice.</br>- Autocomplete should detect the identifiers, which are not spelled correctly or not imported/included.</br>- Auto generated template for documentation is nice ", ["Usability -> Non-invasive -> Asks confirmation before changing code", "Functionality -> Coverage of support -> Support for identifiers", "Functionality -> Provides additional information -> Documentation"]],
    [3,"Correctness (the recommended code must be semantically equivalent to the one I would manually write)</br>Multi Suggestion ( the recommender should suggest at least 2 or 3 offer to developer to select)</br>Adapted to the context (the recommended code is adapted to the code I’m writing, for example reusing variable names when possible)", ["Accuracy of recommendations", "Functionality -> Recommendation modality -> Multiple options available", "Characteristics of recommended code -> Adaptive -> Coding context"]],
    [3,"Usability - must be as easy to use as possibke.</br>Reliability</br>Correctness", ["Usability -> Intuitive", "Characteristics of recommended code -> Code Quality -> Correctness"]],
    [3,"Accuracy, I will take this over correctness, because I can correctly do the wrong thing and not know till I hit compile.", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness"]],
    [3,"Correctness: if its wrong frequently, I'll not use it</br>Not breaking syntax</br>Easy to understand", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness -> Correct syntax", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability"]],
    [3,"I agree with the 3 examples mentioned. Also, it might be interesting for the usefulness of such tools to have code usage examples automatically", ["Functionality -> Provides additional information -> Documentation -> Code example", "Characteristics of recommended code -> Code Quality -> Correctness", "Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Provides additional information -> Documentation"]],
    [3,"I mostly use code completion for function involcations. If I can get longer recommendations as an entire js function, high quality and understandable code is important.", ["Functionality -> Coverage of support -> Support for multi-token code completion -> Entire statement(s)", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Characteristics of recommended code -> Code Quality "]],
    [3,"Accuracy</br>Correctness</br>Adapt to libraries in use</br>Considers past choices", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness", "Functionality -> Coverage of support -> Support for third-party libraries", "Functionality -> Self-improving based on feedback"]],
    [3,"1. Accuracy below 80% is not acceptable</br>2. Correctness</br>3. Pushing good coding standards, either general ones or customized by the user", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness", "Characteristics of recommended code -> Code Quality -> Meets best coding practices "]],
    [3,"Accuracy, as I'd rather search what I need on Google if the recommender returns some unrelated matching.</br>User Friendly, should be easy to use and to understand</br>Usefull, the recommender should be smarter than me, should provide something usefull to the problem that I'm facing ", ["Accuracy of recommendations", "Usability -> Intuitive"]],
    [3,"Quickness is the most important.  If the completions are not timely, it is just easier to type the whole thing myself sometimes.  If I have to wait, or it is too slow, the whole thing because a way that slows me down and makes me unlikely to use it.", ["Functionality -> Early prediction", "Usability -> High responsiveness"]],
    [3,"maintained, fast, adapted ,high security, easy accessable", ["Usability -> High responsiveness", "Characteristics of recommended code -> Adaptive -> Coding context", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability Free", "Usability"]],
    [3,"Presentation style, accuracy, applicable in the current context", ["Usability -> Intuitive", "Accuracy of recommendations", "Characteristics of recommended code -> Structural characteristics -> Easy to integrate in code under development"]],
    [3,"the most important characteristics of code recommendation to me that strongly have an impact on its usefulness are its robustness, its maintainability, and its efficiency. Robustness would be the most important for me as it is important that the recommendation can cope up with any errors during program execution in spite of unusual conditions- if the recommendation can hold up in both usual and unusual conditions then I am more likely to use it. Next would be efficiency. I'm looking for recommendations that do not take a long time to run and perform an action- the better the performance and speed of the recommendation, the more likely I would be interested in using it. Lastly is maintainability. I look for recommendations that are easy to add new features to in the future or ones that I can fix issues with easily and with minimum effort. If the recommendation is too difficult to understand and cannot be corrected or added to easily, then I would not be likely to use it.", ["Characteristics of recommended code -> Code quality -> Robustness", "Characteristics of recommended code -> Code quality -> Performance", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability", "Characteristics of recommended code -> Code quality -> Maintainability"]],
    [3,"recommended code must be documented (so that I can be sure it isn't broken)</br>it must be adapted to the coding context (so that it is useful and does not cause errors)</br>It must use meaningful identifiers (to reduce the amount of work on my end having to make sure that it works)", ["Functionality -> Provides additional information -> Documentation -> Commented code", "Characteristics of recommended code -> Adaptive -> Coding context", "Characteristics of recommended code -> Code Quality -> High Readability and Understandability -> Meaningful identifiers"]],
    [4,"1. Accuracy of the recommendation</br>2. Completeness</br>3. Situational appropriateness - the recommender should have some filters to prevent code not appropriate for the style preferences of the developer from being suggested.", ["Accuracy of recommendations", "Characteristics of recommended code -> Adaptive -> Developer's coding Style"]],
    [4,"Accuracy is by far the most important, even above correctness. (If I intend to write something incorrect, code recommendation should still help me, I could make it correct later).</br>Size of the recommendation: generally, only single tokens are currently recommended. Larger would be better (as long as the recommendation remains trivial to interpret).</br>Good recommendations also provide some context: such as `a (int)` instead of just `a`.", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness", "Functionality -> Coverage of Support -> Support for multi-token code completion", "Characteristics of recommended code -> Code Quality -> High readability and understandability", "Functionality -> Provides additional information -> Documentation"]],
    [4,"Correctness, Accuracy, Having meaningful identifiers (return type, parameters type)", ["Characteristics of recommended code -> Code Quality -> Correctness", "Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> High readability and understandability -> Meaningful identifiers"]],
    [4,"Recommendation should give the right one and help to improve the code quality", ["Accuracy of recommendations", "Characteristics of recommended code -> Code quality"]],
    [4,"1. Mostly quiet unless needed.</br>Getting a recommendation popup on every keystroke can be very distracting. I tend to prefer only having recommendations when typing a `.` accessor on a given object or class instance. Should be a helper and not a bully.</br>2. Suggestions include context.</br>One great feature of Intellisense in particular is the summary that is shown for recommended functions in the popover window. Really improves discoverability of interfaces.</br>3. Accuracy.</br>For JavaScript at least, you often get suggestions that are far, far outside the scope of what you're working on. I'll be making a class method in Ember, and get suggestions for obscure NodeJS API that include auto-imports at the top of the file. This is, at times, very annoying.", ["Usability -> Non-invasive", "Awareness -> Coding context"]],
    [4,"Accuracy is probably the most important characteristic. Knowing you are calling the right method (or overloaded method) can prevent potential bugs. ", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/vulnerability free"]],
    [4,"The code recommender should be accurate, intuitive on how to complete the recommendation, intuitive on how to delete the recommendation if I want to undo it, and intuitive on how to cycle between different suggestions", ["Accuracy of recommendations", "Usability -> Intuitive"]],
    [4,"The most important characteristic is coverage because I want to be able to quickly reference items from many files.", ["Functionality -> Coverage of support"]],
    [4,"adapted to the specific task/code, mostly true positive suggestions (or better no suggestions), improves over time", ["Characteristics of recommended code -> Adaptive -> Coding context", "Functionality -> Self-improving based on feedback", "Awareness -> Developer's tasks"]],
    [4,"Correctness. The solution must be precise.</br>Rapid. The tool must be rapid with zero delay </br>Smart. The suggestion should be not trivial but must address a real issue ", ["Characteristics of recommended code -> Code Quality -> Correctness", "Accuracy of recommendations", "Usability -> High responsiveness", "Functionality -> Coverage of support"]],
    [4,"Customizable. It's essential that the suggestion  reflects the company rules and conventions</br>Correct. The suggestion must be bug free</br>Appropriate. The suggestion must reflect the code already developed, see name convention, API usage, inline and lambda function", ["Characteristics of recommended code -> Code Quality -> Meets best coding practices -> meets company/client standards", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability free", "Characteristics of recommended code -> Adaptive -> Coding context"]],
    [4,"The code must be documented and easy to understand.", ["Functionality -> Provides additional information -> Documentation", "Characteristics of recommended code -> Code Quality -> High readability and understandability"]],
    [4,"Correctness, Accuracy and, where it's possible, secure ", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability free"]],
    [4,"it's important that the prediction is available soon enough to save time while coding</br>ranking of suggestions is often unclear, should be configurable and allow for specific criteria</br>the tool should learn from my past behavior: understand when I need or do not need recommendations", ["Functionality -> Early prediction", "Functionality -> Configurable", "Functionality -> Self-improving based on feedback", "Functionality -> Recommendation Modality -> Smart ranking"]],
    [4,"Accuracy: the most accurate the recommendation is, the most the typing time I can save. I often accept the recommendation also if it's not 100% accurate if I think adjusting it takes less time than writing it entirely</br>Conciseness: I usually don't accept long recommedations. I prefer to accept more short recommendations instead of a single long one because stopping to understand a long piece of code interrupts my programming flow. Accepting short recommendations instead gives me the feeling of enhancing the flow</br>Easy to understand: if I don't understand what the suggestions is about at first glance, I ignore it and I continue programming", ["Accuracy of recommendations", "Characteristics of recommended code -> Code Quality -> High readability and understandability -> Concise code", "Characteristics of recommended code -> Code Quality -> High readability and understandability"]],
    [4,"accuracy, otherwise I'll wast time</br>speed, otherwise not usable</br>smart, able to learn and customize suggestions</br>reliable, not recommending dangerous code (not secure, not maintainable)", ["Accuracy of recommendations", "Usability -> High responsiveness", "Functionality -> Self-improving based on feedback", "Characteristics of recommended code -> Code Quality -> Correctness -> Bug/Vulnerability free", "Characteristics of recommended code -> Code Quality -> Maintainability"]],
    [4,"Regarding token definition, readability is very important. If I am creating a variable of type UserTransaction or UserDTO I likely want the IDE to suggest only transaction and dto as name</br> Correctness is in my opinion the most important characteristic of code recommender tools, which is one of the reason I took a break from using GitHub Copilot.  </br> Lastly it should be able to adapt. Not necessarily by being a DL model, just a simple heuristic such as “if method x is usually selected when presented in the list of suggestions, it should be ranked higher”", ["Characteristics of recommended code -> Code quality -> High readability and understandability -> Meaningful identifiers", "Characteristics of recommended code -> Code quality -> Correctness", "Functionality -> Self-improving based on feedback"]],
    [4,"The suggestion of the solution must be clear, easy to understand, documented, maybe with clearer examples.", ["Characteristics of recommended code -> Code quality -> High readability and understandability", "Functionality -> Provides additional information  -> Documentation"]],
    [4,"the recommended code must be correct and easy to understand/verify.</br> the recommended code should be in sync with my other code.", ["Characteristics of recommended code -> Code quality -> Correctness", "Characteristics of recommended code -> Code quality -> High readability and understandability", "Awareness -> Coding history"]],
    [4,"correctness</br> make it easy to spot potential bugs in the recommendation, I must be comfortable in deciding if to accept or not it", ["Characteristics of recommended code -> Code quality -> Correctness"]]

];




table_data=[ table_data_coverage, table_data_accuracy, table_data_usability, table_data_characteristics]

function create_list(list) {

    /* create the unordered list with all the characteristics*/
    var ul = document.createElement("ul");

    for (let i = 0; i < list.length; i++) {
        var elem = document.createElement('li');

        var temp=list[i]

        /* replace -> character with &gt;*/
        temp=temp.replaceAll("->", "&gt;");

        
        elem.innerHTML = temp;
        ul.appendChild(elem);
    }

    return ul.outerHTML
}

tabs=["coverage", "accuracy", "usability", "characteristics"]

for (let t=0; t<tabs.length; t++){

    var name="export-"+tabs[t]

    var tableBody = document.createElement('tbody');

    table_data[t].forEach(function (rowData) {
        /* create all the rows*/
        var row = document.createElement('tr');


        for (let i = 0; i < rowData.length; i++) {
            var cell = document.createElement('td');
            cellData = rowData[i];
            if (i != 2) {
                cell.innerHTML = cellData;
            }
            else {

                cell.innerHTML = create_list(cellData);

            }

            if (i==0){ /* centering the round column*/
                cell.classList.add("text-center");

            }

            row.appendChild(cell);
        }

        tableBody.appendChild(row);
    });

    document.getElementById(name).appendChild(tableBody);
}